对账的计算方法
核心是确保 Vault 总余额能覆盖池子储备量和协议费用，这是资金安全的基础。
一、系统资金架构

ChatOneSwap 采用三层架构：

┌─────────────────────────────────────┐
│         Vault (资金存储层)            │
│  - balances[token]: 总余额            │
│  - lpReserves[token]: LP储备量        │
│  - protocolFees[token]: 协议费用      │
└─────────────────────────────────────┘
           ↑              ↑
           │              │
    ┌──────┴──────┐  ┌────┴────┐
    │ PoolManager │  │ Protocol│
    │ (池子储备量)  │  │  (费用)  │
    └─────────────┘  └─────────┘

二、核心概念定义

1. Vault总余额 (balances[token])
- 定义：Vault 中某个代币的总余额
- 来源：所有存入 Vault 的代币总和
- 特点：最准确的资金总量
- 公式：Vault总余额 = 所有存入 - 所有取出
  
2. 池子储备量 (pool.reserve0/reserve1)
- 定义：池子中当前实际的代币储备量
- 更新时机：
  - 添加流动性时：reserve += amount
  - 移除流动性时：reserve -= amount
  - 交易时：reserve += amountInForReserves - amountOut
- 特点：反映池子当前实际状态，包含 LP 获得的手续费
  
3. LP储备量 (lpReserves[token])
- 定义：流动性提供者存入的资金记录
- 更新时机：
  - 添加流动性时：lpReserves += amount ✅
  - 移除流动性时：lpReserves -= amount ✅
  - 交易时：不更新 ❌
- 特点：仅记录 LP 的初始存入，不包含交易带来的手续费
  
4. 协议费用 (protocolFees[token])
- 定义：协议从交易手续费中获得的费用
- 计算：协议费用 = swapFeeAmount * protocolFee / 10000
- 特点：独立记录，可提取
  
三、对账的核心公式

公式1：Vault总余额分解（最核心）

Vault总余额 = 池子储备量 + 协议费用 + 其他资金

其中：
- 池子储备量：当前池子中的实际资金
- 协议费用：协议获得的费用
- 其他资金：Vault 中除上述两项外的资金（通常为 0 或很小）
  
公式2：核心验证（资金安全）

Vault总余额 >= 池子储备量 + 协议费用

这是最核心的验证，确保：
- Vault 中的资金足够覆盖池子储备量
- 协议费用已正确累积
- 没有资金丢失
  
公式3：LP储备量与池子储备量的关系

池子储备量 = LP储备量 + LP获得的手续费 - 已移除的流动性

说明：
- 如果 池子储备量 > LP储备量：差异 = LP 通过交易获得的手续费
- 如果 LP储备量 > 池子储备量：差异 = 已移除的流动性（LP储备量未正确更新）
  
四、对账计算方法

步骤1：获取基础数据

// 1. Vault总余额（最准确）
vaultBalance = await vault.getBalance(token)

// 2. 池子储备量（当前实际值）
poolReserve = await poolManager.pools(poolKey).reserve0

// 3. LP储备量（初始值，仅供参考）
lpReserve = await vault.lpReserves(token)

// 4. 协议费用
protocolFee = await vault.getProtocolFee(token)

步骤2：计算其他资金

// Vault中除了池子储备量和协议费用外的其他资金
otherFunds = vaultBalance - poolReserve - protocolFee

步骤3：核心验证

// 验证1：Vault总余额完整性
expectedBalance = poolReserve + protocolFee + otherFunds
isValid = vaultBalance === expectedBalance  // 允许小的舍入误差

// 验证2：资金安全（最核心）
isSafe = vaultBalance >= poolReserve + protocolFee

// 验证3：其他资金合理性
isOtherFundsValid = otherFunds >= 0

步骤4：差异分析

// LP储备量与池子储备量的差异
lpReserveDiff = lpReserve - poolReserve

if (lpReserveDiff > 0) {
  // LP储备量 > 池子储备量
  // 说明：已移除的流动性，但LP储备量可能未正确更新
} else if (lpReserveDiff < 0) {
  // 池子储备量 > LP储备量
  // 说明：LP通过交易获得的手续费
  lpFee = poolReserve - lpReserve
}

五、对账验证优先级

优先级1：Vault总余额验证（最高优先级）
✅ Vault总余额 >= 池子储备量 + 协议费用
这是资金安全的底线，必须通过。

优先级2：资金完整性验证
✅ Vault总余额 = 池子储备量 + 协议费用 + 其他资金
确保所有资金都有明确归属。

优先级3：总供应量验证
✅ 代币总供应量 = 所有地址余额总和
确保没有代币丢失或未统计。

优先级4：LP储备量验证（仅供参考）
⚠️ LP储备量 vs 池子储备量（仅供参考，不作为核心验证）
LP储备量可能不准确，仅作参考。

六、实际对账流程

1. 获取Vault总余额
   ↓
2. 获取池子储备量（当前实际值）
   ↓
3. 获取协议费用
   ↓
4. 计算其他资金 = Vault总余额 - 池子储备量 - 协议费用
   ↓
5. 核心验证：Vault总余额 >= 池子储备量 + 协议费用
   ↓
6. 完整性验证：Vault总余额 = 池子储备量 + 协议费用 + 其他资金
   ↓
7. 总供应量验证：总供应量 = 所有地址余额总和
   ↓
8. 差异分析：解释LP储备量与池子储备量的差异

七、关键原则

1. 以 Vault 总余额为准：最准确
2. 以池子储备量为实际值：LP储备量可能不准确
3. 核心验证优先：Vault总余额 >= 池子储备量 + 协议费用
4. 差异需可解释：LP储备量与池子储备量的差异应有合理解释
  
八、示例计算

假设：
- Vault总余额 = 1000
- 池子储备量 = 950
- 协议费用 = 20
- LP储备量 = 1000（初始值）
  
计算：
其他资金 = 1000 - 950 - 20 = 30

核心验证：1000 >= 950 + 20 ✅ 通过
完整性验证：1000 = 950 + 20 + 30 ✅ 通过

LP储备量差异：1000 - 950 = 50
说明：LP储备量记录的是初始值，池子储备量是当前值
差异50可能是已移除的流动性，或LP获得的手续费